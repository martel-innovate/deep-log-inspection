#
# delete dimensions.path as it was required by the Monasca Log API
# but isn't necessary
#
# the date-match operation sets the timestamp to the value of log_date
#
input {
	kafka {
		bootstrap_servers => "kafka:9092"
		topics => ["monasca-log"]
		codec => "json"
	}
}

filter {

	mutate {
		rename => { "[log][message]" => "msg_full" }
		rename => { "[log][dimensions]" => "dimensions" }
		rename => { "[dimensions][logsource]" => "node_source" }
		rename => { "[dimensions][host]" => "node_ip" }
		remove_field => [ "log" ]
		remove_field => [ "[dimensions][path]" ]
	}

	grok {
		match => {
			"msg_full" => "^%{NOTSPACE:node_service} %{TIMESTAMP_ISO8601:log_date}%{SPACE}%{NUMBER:log_pid}?%{SPACE}?%{LOGLEVEL:log_level} \[?\b%{NOTSPACE:log_module}\b\]?%{SPACE}?%{GREEDYDATA:msg}?"
		}
	}

	date {
		match => [ "log_date", "ISO8601" ]
	}
	mutate {
		remove_field => [ "log_date", "msg_full" ]
	}

	if "nova" in [node_service] {
		mutate {
			add_tag => [ "nova" ]
		}
	} else if "cinder" in [node_service] {
		mutate {
			add_tag => [ "cinder" ]
		}
	} else if "neutron" in [node_service] {
		mutate {
			add_tag => [ "neutron" ]
		}
	} else if "keystone" in [node_service] {
		mutate {
			add_tag => [ "keystone" ]
		}
	}

	if [node_service] == "nova-api" {

		if [log_module] == "nova.osapi_compute.wsgi.server" {

			mutate {
				gsub => [ "msg", "\"", "" ]
			}
			grok {
				match => {
					"msg" => "\[(req)?\-(%{NOTSPACE:msg_request_id} %{NOTSPACE:msg_uid} %{NOTSPACE:msg_tenant} \- \- \-)?\] %{IPV4:msg_request_ip} %{NOTSPACE:msg_method} %{NOTSPACE:msg_url} %{NOTSPACE:msg_http_ver} status\: %{NUMBER:msg_response_status} len\: %{NUMBER:msg_bytes} time\: %{NUMBER:msg_time_sec}"
				}
			}

		} else if [log_module] == "nova.metadata.wsgi.server" {

			mutate {
				gsub => [ "msg", "\"", "" ]
			}
			grok {
				match => {
					"msg" => "\[(req)?\-(%{NOTSPACE:msg_request_id} \- \- \- \- \-)?\] (%{IPV4:msg_request_ip_global},)?%{IPV4:msg_request_ip_local} %{NOTSPACE:msg_method} %{NOTSPACE:msg_url} %{NOTSPACE:msg_http_ver} status\: %{NUMBER:msg_response_status} len\: %{NUMBER:msg_bytes} time\: %{NUMBER:msg_time_sec}"
				}
			}

		}

	} else if [node_service] == "neutron-api" {

		if [log_module] == "neutron.wsgi" {
			if "accepted" not in [msg] {
				mutate {
					gsub => [ "msg", "\"", "" ]
				}
				grok {
					match => {
						"msg" => "\[(req)?\-(%{NOTSPACE:msg_request_id} )?\] %{IPV4:msg_request_ip} \- \- \[(?<msg_request_date>%{NOTSPACE} %{TIME})\] %{NOTSPACE:msg_method} %{NOTSPACE:msg_url} %{NOTSPACE:msg_http_ver} %{NUMBER:msg_response_status} %{NUMBER:msg_bytes} %{NUMBER:msg_time_sec}"
					}
				}
			}
		}

	} else if [node_service] == "cinder-api" {

		if [log_module] == "eventlet.wsgi.server" {
			if "accepted" not in [msg] {
				mutate {
					gsub => [ "msg", "\"", "" ]
				}
				grok {
					match => {
						"msg" => "\[(req)?\-(%{NOTSPACE:msg_request_id} %{NOTSPACE:msg_uid} %{NOTSPACE:msg_tenant} \- \- \-)?\] (%{IPV4:msg_request_ip_global},)?%{IPV4:msg_request_ip_local} \- \- \[(?<msg_request_date>%{NOTSPACE} %{TIME})\] %{NOTSPACE:msg_method} %{NOTSPACE:msg_url} %{NOTSPACE:msg_http_ver} %{NUMBER:msg_response_status} %{NUMBER:msg_bytes} %{NUMBER:msg_time_sec}"
					}
				}
			}
		}

	} else if [node_service] == "nova-compute" {

		if [log_module] == "nova.compute.resource_tracker" {
			grok {
				match => {
					"msg" => [
					"\[req\-%{NOTSPACE:msg_request_id} \- \- \- \- \-\] Total usable vcpus: %{NUMBER:resource_total_vcpus:int}, total allocated vcpus: %{NUMBER:resource_used_vcpus:int}",
					"\[req\-%{NOTSPACE:msg_request_id} \- \- \- \- \-\] Final resource view: name=%{NOTSPACE:resource_name} phys_ram=%{NUMBER:resource_physical_ram:int}MB used_ram=%{NUMBER:resource_used_ram:int}MB phys_disk=%{NUMBER:resource_physical_disk:int}GB used_disk=%{NUMBER:resource_used_disk:int}GB total_vcpus=%{NUMBER:resource_total_vcpus:int} used_vcpus=%{NUMBER:resource_used_vcpus:int} pci_stats=(?<pci_stats><nova.pci.stats.PciDeviceStats object at %{BASE16NUM}>)"
					]
				}
			}
		}

	}  else if [node_service] == "keystone" {

		if [log_module] == "eventlet.wsgi.server" {
			mutate {
				gsub => [ "msg", "\"", "" ]
			}
			grok {
				match => {
					"msg" => "\[\-\] (%{IPV4:msg_request_ip_global},)?%{IPV4:msg_request_ip_local} \- \- \[(?<msg_request_date>%{NOTSPACE} %{TIME})\] %{NOTSPACE:msg_method} %{NOTSPACE:msg_url} %{NOTSPACE:msg_http_ver} %{NUMBER:msg_response_status} %{NUMBER:msg_bytes} %{NUMBER:msg_time_sec}"
				}
			}
		}

	}

}

output {
	kafka {
		bootstrap_servers => "kafka:9092"
		topic_id => "logstash-log"
		codec => "json"
	}
	file {
		path => ['/logs/transformed.log']
	}
}
